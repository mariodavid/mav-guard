= Java API

This guide covers using MavGuard programmatically from Java applications, without the command-line interface.

== Overview

MavGuard's core functionality is available as a Java API, allowing integration into:

* IDE plugins and extensions
* Build tools and Maven plugins
* CI/CD systems and automation tools
* Custom analysis applications
* Enterprise dependency management systems

== Getting Started

=== Maven Dependency

Add MavGuard modules to your project:

[source,xml]
----
<dependencies>
    <!-- Core model objects -->
    <dependency>
        <groupId>de.diedavids</groupId>
        <artifactId>mav-guard-model</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </dependency>
    
    <!-- POM parsing capabilities -->
    <dependency>
        <groupId>de.diedavids</groupId>
        <artifactId>mav-guard-xml-parser</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </dependency>
    
    <!-- Version checking (optional) -->
    <dependency>
        <groupId>de.diedavids</groupId>
        <artifactId>mav-guard-nexus</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </dependency>
</dependencies>
----

=== Basic Usage Example

[source,java]
----
import de.diedavids.mavguard.model.Project;
import de.diedavids.mavguard.xmlparser.PomParser;
import java.io.File;

public class MavGuardExample {
    public static void main(String[] args) {
        // Initialize parser
        PomParser parser = new PomParser();
        
        // Parse a POM file
        File pomFile = new File("pom.xml");
        Project project = parser.parsePomFile(pomFile);
        
        // Access project information
        System.out.println("Project: " + project.coordinates());
        System.out.println("Dependencies: " + project.dependencies().size());
        
        // Process dependencies
        project.dependencies().forEach(dep -> 
            System.out.println("  " + dep.coordinates() + " (" + dep.scope() + ")")
        );
    }
}
----

== Core API Components

=== POM Parsing

==== Single Module Projects

[source,java]
----
import de.diedavids.mavguard.xmlparser.PomParser;
import de.diedavids.mavguard.model.Project;

// Initialize parser
PomParser parser = new PomParser();

// Parse from File
File pomFile = new File("/path/to/pom.xml");
Project project = parser.parsePomFile(pomFile);

// Parse from InputStream
try (InputStream inputStream = new FileInputStream(pomFile)) {
    Project project = parser.parsePomFromStream(inputStream);
}

// Parse from String
String pomXml = Files.readString(pomFile.toPath());
Project project = parser.parsePomFromString(pomXml);
----

==== Multi-Module Projects

[source,java]
----
import de.diedavids.mavguard.xmlparser.MultiModuleDependencyCollector;

// Parse multi-module project
File rootPom = new File("/path/to/root/pom.xml");
List<Project> projects = parser.parseMultiModuleProject(rootPom);

// Collect and analyze dependencies
MultiModuleDependencyCollector collector = new MultiModuleDependencyCollector();
var report = collector.collectDependencies(projects);

// Check for inconsistencies
if (report.hasVersionInconsistencies()) {
    report.getVersionInconsistencies().forEach((coords, versions) -> {
        System.out.println("Inconsistent versions for " + coords + ": " + versions);
    });
}

// Get consolidated dependencies
Map<String, Dependency> consolidatedDeps = report.getConsolidatedDependencies();
consolidatedDeps.forEach((coords, dependency) -> {
    List<String> usingModules = report.getModulesUsingDependency(coords);
    System.out.println(coords + " used by: " + usingModules);
});
----

=== Version Checking

[source,java]
----
import de.diedavids.mavguard.nexus.DependencyVersionService;

@Autowired
private DependencyVersionService versionService;

// Check for latest version
String groupId = "org.springframework";
String artifactId = "spring-core";
String currentVersion = "6.2.2";

Optional<String> latestVersion = versionService.getLatestVersion(groupId, artifactId);
if (latestVersion.isPresent() && !latestVersion.get().equals(currentVersion)) {
    System.out.println("Update available: " + currentVersion + " -> " + latestVersion.get());
}

// Check multiple dependencies
List<Dependency> dependencies = project.dependencies();
for (Dependency dep : dependencies) {
    Optional<String> latest = versionService.getLatestVersion(
        dep.coordinates().groupId(), 
        dep.coordinates().artifactId()
    );
    // Process update information
}
----

=== Spring Configuration

[source,java]
----
@Configuration
@ComponentScan(basePackages = "de.diedavids.mavguard")
public class MavGuardConfig {
    
    @Bean
    public PomParser pomParser() {
        return new PomParser();
    }
    
    @Bean
    public MultiModuleDependencyCollector dependencyCollector() {
        return new MultiModuleDependencyCollector();
    }
    
    @Bean
    @ConditionalOnProperty(name = "mavguard.repository.type", havingValue = "nexus")
    public DependencyVersionService nexusVersionService() {
        return new NexusDependencyVersionService();
    }
    
    @Bean
    @ConditionalOnMissingBean
    public DependencyVersionService mavenCentralVersionService() {
        return new MavenCentralVersionService();
    }
}
----

== Advanced Usage Patterns

=== Custom Analysis Pipeline

[source,java]
----
public class DependencyAnalyzer {
    private final PomParser pomParser;
    private final DependencyVersionService versionService;
    private final MultiModuleDependencyCollector collector;
    
    public AnalysisResult analyze(File pomFile) {
        // Parse project(s)
        List<Project> projects = detectAndParse(pomFile);
        
        // Collect dependencies
        var dependencyReport = collector.collectDependencies(projects);
        
        // Check for updates
        Map<String, UpdateInfo> updates = checkForUpdates(dependencyReport);
        
        // Generate analysis result
        return AnalysisResult.builder()
            .projects(projects)
            .dependencyReport(dependencyReport)
            .updates(updates)
            .build();
    }
    
    private List<Project> detectAndParse(File pomFile) {
        try {
            return pomParser.parseMultiModuleProject(pomFile);
        } catch (Exception e) {
            // Fallback to single module
            return List.of(pomParser.parsePomFile(pomFile));
        }
    }
    
    private Map<String, UpdateInfo> checkForUpdates(DependencyReport report) {
        Map<String, UpdateInfo> updates = new HashMap<>();
        
        report.getConsolidatedDependencies().forEach((coords, dependency) -> {
            String[] parts = coords.split(":");
            Optional<String> latest = versionService.getLatestVersion(parts[0], parts[1]);
            
            if (latest.isPresent() && !latest.get().equals(dependency.coordinates().version())) {
                updates.put(coords, UpdateInfo.of(dependency.coordinates().version(), latest.get()));
            }
        });
        
        return updates;
    }
}
----

=== Parallel Processing

[source,java]
----
public class ParallelDependencyChecker {
    private final DependencyVersionService versionService;
    private final ExecutorService executorService;
    
    public CompletableFuture<Map<String, String>> checkUpdatesAsync(List<Dependency> dependencies) {
        List<CompletableFuture<UpdateResult>> futures = dependencies.stream()
            .map(this::checkSingleDependency)
            .toList();
            
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .filter(result -> result.hasUpdate())
                .collect(Collectors.toMap(
                    UpdateResult::coordinates,
                    UpdateResult::latestVersion
                )));
    }
    
    private CompletableFuture<UpdateResult> checkSingleDependency(Dependency dependency) {
        return CompletableFuture.supplyAsync(() -> {
            Optional<String> latest = versionService.getLatestVersion(
                dependency.coordinates().groupId(),
                dependency.coordinates().artifactId()
            );
            return new UpdateResult(
                dependency.coordinates().toString(),
                dependency.coordinates().version(),
                latest.orElse(dependency.coordinates().version())
            );
        }, executorService);
    }
}
----

=== Custom Output Formatting

[source,java]
----
public interface AnalysisFormatter {
    void format(AnalysisResult result, Writer output) throws IOException;
}

public class JsonAnalysisFormatter implements AnalysisFormatter {
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    @Override
    public void format(AnalysisResult result, Writer output) throws IOException {
        JsonNode jsonResult = createJsonReport(result);
        objectMapper.writeValue(output, jsonResult);
    }
    
    private JsonNode createJsonReport(AnalysisResult result) {
        ObjectNode root = objectMapper.createObjectNode();
        
        // Add project information
        ArrayNode projects = root.putArray("projects");
        result.projects().forEach(project -> {
            ObjectNode projectNode = projects.addObject();
            projectNode.put("groupId", project.coordinates().groupId());
            projectNode.put("artifactId", project.coordinates().artifactId());
            projectNode.put("version", project.coordinates().version());
            projectNode.put("dependencyCount", project.dependencies().size());
        });
        
        // Add update information
        ObjectNode updates = root.putObject("updates");
        result.updates().forEach((coords, updateInfo) -> {
            ObjectNode updateNode = updates.putObject(coords);
            updateNode.put("current", updateInfo.currentVersion());
            updateNode.put("latest", updateInfo.latestVersion());
        });
        
        return root;
    }
}
----

== Error Handling

=== Exception Hierarchy

[source,java]
----
try {
    Project project = parser.parsePomFile(pomFile);
} catch (PomParseException e) {
    // Handle POM parsing errors
    logger.error("Failed to parse POM file: {}", e.getMessage());
} catch (PropertyResolutionException e) {
    // Handle property resolution issues
    logger.warn("Could not resolve all properties: {}", e.getMessage());
} catch (IOException e) {
    // Handle file I/O errors
    logger.error("File access error: {}", e.getMessage());
}
----

=== Graceful Degradation

[source,java]
----
public class RobustAnalyzer {
    
    public AnalysisResult analyzeWithFallback(File pomFile) {
        AnalysisResult.Builder builder = AnalysisResult.builder();
        
        try {
            // Try multi-module first
            List<Project> projects = pomParser.parseMultiModuleProject(pomFile);
            builder.projects(projects);
        } catch (Exception e) {
            logger.debug("Multi-module parsing failed, trying single module", e);
            try {
                Project project = pomParser.parsePomFile(pomFile);
                builder.projects(List.of(project));
            } catch (Exception e2) {
                logger.error("All parsing attempts failed", e2);
                throw new AnalysisException("Could not parse project", e2);
            }
        }
        
        // Continue with analysis even if some steps fail
        try {
            Map<String, UpdateInfo> updates = checkForUpdates(builder.getProjects());
            builder.updates(updates);
        } catch (Exception e) {
            logger.warn("Update checking failed, continuing without updates", e);
            builder.updates(Collections.emptyMap());
        }
        
        return builder.build();
    }
}
----

=== Validation and Constraints

[source,java]
----
public class ProjectValidator {
    
    public ValidationResult validate(Project project) {
        ValidationResult.Builder result = ValidationResult.builder();
        
        // Validate coordinates
        if (project.coordinates().groupId().isEmpty()) {
            result.addError("Group ID cannot be empty");
        }
        
        if (project.coordinates().artifactId().isEmpty()) {
            result.addError("Artifact ID cannot be empty");
        }
        
        // Validate dependencies
        Set<String> duplicateCheck = new HashSet<>();
        for (Dependency dep : project.dependencies()) {
            String key = dep.coordinates().groupId() + ":" + dep.coordinates().artifactId();
            if (!duplicateCheck.add(key)) {
                result.addWarning("Duplicate dependency: " + key);
            }
            
            if (dep.coordinates().version().contains("SNAPSHOT") && "compile".equals(dep.scope())) {
                result.addWarning("SNAPSHOT dependency in compile scope: " + key);
            }
        }
        
        return result.build();
    }
}
----

== Integration Examples

=== Maven Plugin Integration

[source,java]
----
@Mojo(name = "analyze", defaultPhase = LifecyclePhase.VERIFY)
public class MavGuardAnalyzeMojo extends AbstractMojo {
    
    @Parameter(defaultValue = "${project.basedir}/pom.xml", property = "pomFile")
    private File pomFile;
    
    @Component
    private PomParser pomParser;
    
    @Override
    public void execute() throws MojoExecutionException {
        try {
            Project project = pomParser.parsePomFile(pomFile);
            
            getLog().info("Analyzed project: " + project.coordinates());
            getLog().info("Dependencies found: " + project.dependencies().size());
            
            // Additional analysis logic
            
        } catch (Exception e) {
            throw new MojoExecutionException("Analysis failed", e);
        }
    }
}
----

=== Gradle Plugin Integration

[source,java]
----
public class MavGuardPlugin implements Plugin<Project> {
    
    @Override
    public void apply(Project project) {
        project.getTasks().register("mavguardAnalyze", MavGuardAnalyzeTask.class, task -> {
            task.setGroup("verification");
            task.setDescription("Analyze Maven dependencies using MavGuard");
        });
    }
}

public class MavGuardAnalyzeTask extends DefaultTask {
    
    @TaskAction
    public void analyze() {
        File pomFile = getProject().file("pom.xml");
        if (!pomFile.exists()) {
            throw new GradleException("pom.xml not found");
        }
        
        PomParser parser = new PomParser();
        de.diedavids.mavguard.model.Project mavProject = parser.parsePomFile(pomFile);
        
        getLogger().lifecycle("Analyzed Maven project: {}", mavProject.coordinates());
    }
}
----

=== REST API Integration

[source,java]
----
@RestController
@RequestMapping("/api/analysis")
public class AnalysisController {
    
    @Autowired
    private DependencyAnalyzer analyzer;
    
    @PostMapping("/upload")
    public ResponseEntity<AnalysisResult> analyzePom(@RequestParam("file") MultipartFile file) {
        try {
            File tempFile = File.createTempFile("pom", ".xml");
            file.transferTo(tempFile);
            
            AnalysisResult result = analyzer.analyze(tempFile);
            
            tempFile.delete();
            return ResponseEntity.ok(result);
            
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(AnalysisResult.error(e.getMessage()));
        }
    }
    
    @GetMapping("/project/{groupId}/{artifactId}")
    public ResponseEntity<UpdateInfo> checkUpdates(
            @PathVariable String groupId,
            @PathVariable String artifactId,
            @RequestParam String currentVersion) {
        
        // Implementation for checking specific dependency updates
        return ResponseEntity.ok(updateInfo);
    }
}
----

== Performance Considerations

=== Caching Strategies

[source,java]
----
@Component
public class CachedVersionService implements DependencyVersionService {
    private final Cache<String, Optional<String>> versionCache;
    private final DependencyVersionService delegate;
    
    public CachedVersionService(DependencyVersionService delegate) {
        this.delegate = delegate;
        this.versionCache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(Duration.ofHours(1))
            .build();
    }
    
    @Override
    public Optional<String> getLatestVersion(String groupId, String artifactId) {
        String key = groupId + ":" + artifactId;
        return versionCache.get(key, k -> delegate.getLatestVersion(groupId, artifactId));
    }
}
----

=== Memory Management

[source,java]
----
public class StreamingAnalyzer {
    
    public void analyzeProjects(Stream<File> pomFiles, Consumer<AnalysisResult> resultHandler) {
        pomFiles.parallel()
            .map(this::analyzeSingle)
            .forEach(resultHandler);
    }
    
    private AnalysisResult analyzeSingle(File pomFile) {
        try {
            // Use try-with-resources for automatic cleanup
            try (InputStream stream = new FileInputStream(pomFile)) {
                Project project = pomParser.parsePomFromStream(stream);
                return AnalysisResult.success(project);
            }
        } catch (Exception e) {
            return AnalysisResult.error(e.getMessage());
        }
    }
}
----

== Next Steps

* Explore the <<model-api.adoc#,Model API>> for domain objects
* Learn about <<parser-api.adoc#,Parser API>> for advanced parsing scenarios
* Review <<../reference/configuration-reference.adoc#,configuration options>>
* See <<../examples/integration-examples.adoc#,complete integration examples>>