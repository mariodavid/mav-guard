= Model API

This document describes the core domain model of MavGuard, implemented using Java Records.

== Overview

MavGuard's domain model is designed around immutable Java Records that represent Maven concepts:

* **Project**: A Maven project with coordinates and dependencies
* **Dependency**: A Maven dependency with scope and version
* **ProjectCoordinates**: GAV (Group, Artifact, Version) coordinates

== Project Record

The central domain object representing a Maven project:

[source,java]
----
public record Project(
    ProjectCoordinates coordinates,
    Optional<ProjectCoordinates> parent,
    List<Dependency> dependencies,
    List<PluginDependency> pluginDependencies
) {
    // Validation and helper methods
}
----

=== Usage Examples

[source,java]
----
// Create a project
Project project = new Project(
    new ProjectCoordinates("com.example", "my-app", "1.0.0"),
    Optional.of(new ProjectCoordinates("org.springframework.boot", "spring-boot-starter-parent", "3.4.5")),
    List.of(
        new Dependency(
            new ProjectCoordinates("org.springframework", "spring-core", "6.2.2"),
            "compile"
        )
    ),
    List.of()
);

// Access project information
String groupId = project.coordinates().groupId();
boolean hasParent = project.parent().isPresent();
int dependencyCount = project.dependencies().size();
----

== Dependency Record

Represents a Maven dependency with scope information:

[source,java]
----
public record Dependency(
    ProjectCoordinates coordinates,
    String scope
) {
    public static final String DEFAULT_SCOPE = "compile";
    
    // Convenience constructor for compile scope
    public Dependency(ProjectCoordinates coordinates) {
        this(coordinates, DEFAULT_SCOPE);
    }
}
----

=== Scope Handling

[source,java]
----
// Different dependency scopes
Dependency compileDep = new Dependency(coords, "compile");
Dependency testDep = new Dependency(coords, "test");
Dependency runtimeDep = new Dependency(coords, "runtime");

// Check scope
if ("test".equals(dependency.scope())) {
    // Handle test dependency
}
----

== ProjectCoordinates Record

Maven GAV coordinates:

[source,java]
----
public record ProjectCoordinates(
    String groupId,
    String artifactId,
    String version
) {
    @Override
    public String toString() {
        return groupId + ":" + artifactId + ":" + version;
    }
}
----

=== Coordinate Parsing

[source,java]
----
// Create from string
ProjectCoordinates coords = ProjectCoordinates.parse("org.springframework:spring-core:6.2.2");

// Manual creation
ProjectCoordinates coords = new ProjectCoordinates("org.springframework", "spring-core", "6.2.2");

// Comparison
boolean same = coords1.equals(coords2);
----

== Immutability Benefits

All domain objects are immutable, providing:

* **Thread Safety**: Safe to use across multiple threads
* **Predictability**: Objects cannot change after creation
* **Caching**: Safe to cache without defensive copying
* **Testing**: Easier to test with predictable state

== Builder Patterns

For complex object creation, builder patterns are available:

[source,java]
----
Project project = Project.builder()
    .coordinates(new ProjectCoordinates("com.example", "app", "1.0.0"))
    .parent(parentCoords)
    .dependency(springCore)
    .dependency(junitTest)
    .build();
----

== Validation

Records include validation for required fields:

[source,java]
----
// These will throw IllegalArgumentException
new ProjectCoordinates(null, "artifact", "1.0.0");  // null groupId
new ProjectCoordinates("", "artifact", "1.0.0");     // empty groupId
new Dependency(coords, null);                         // null scope
----

== Collection Handling

All collections in the model are immutable:

[source,java]
----
List<Dependency> dependencies = project.dependencies();
// This will throw UnsupportedOperationException:
// dependencies.add(newDependency);

// To modify, create a new project
List<Dependency> newDependencies = new ArrayList<>(dependencies);
newDependencies.add(newDependency);
Project newProject = new Project(
    project.coordinates(),
    project.parent(),
    List.copyOf(newDependencies),
    project.pluginDependencies()
);
----

== Integration with Parsing

The model integrates seamlessly with the parsing layer:

[source,java]
----
// Parser returns domain objects
PomParser parser = new PomParser();
Project project = parser.parsePomFile(pomFile);

// Work with typed, validated objects
project.dependencies().stream()
    .filter(dep -> "test".equals(dep.scope()))
    .map(dep -> dep.coordinates().toString())
    .forEach(System.out::println);
----

For usage examples, see the <<java-api.adoc#,Java API Guide>>.