= Parser API

This document covers the XML parsing capabilities of MavGuard for advanced usage scenarios.

== Overview

The `mav-guard-xml-parser` module provides comprehensive POM file parsing with support for:

* Single and multi-module Maven projects
* Maven property resolution and inheritance
* Dependency conflict resolution
* Parent POM relationship handling

== Core Parser Classes

=== PomParser

The main entry point for POM file parsing:

[source,java]
----
public class PomParser {
    
    // Parse single POM file
    public Project parsePomFile(File pomFile) throws PomParseException;
    
    // Parse from InputStream
    public Project parsePomFromStream(InputStream inputStream) throws PomParseException;
    
    // Parse multi-module project
    public List<Project> parseMultiModuleProject(File rootPomFile) throws PomParseException;
    
    // Parse with custom configuration
    public Project parsePomFile(File pomFile, ParseConfiguration config) throws PomParseException;
}
----

=== Basic Usage

[source,java]
----
// Initialize parser
PomParser parser = new PomParser();

// Parse single module
File pomFile = new File("pom.xml");
Project project = parser.parsePomFile(pomFile);

// Access parsed information
System.out.println("Project: " + project.coordinates());
System.out.println("Dependencies: " + project.dependencies().size());
----

=== Multi-Module Parsing

[source,java]
----
// Parse entire multi-module project
File rootPom = new File("pom.xml");
List<Project> projects = parser.parseMultiModuleProject(rootPom);

// Process all modules
for (Project project : projects) {
    System.out.println("Module: " + project.coordinates());
    System.out.println("Dependencies: " + project.dependencies().size());
}
----

== MultiModuleDependencyCollector

Aggregates and analyzes dependencies across multiple modules:

[source,java]
----
public class MultiModuleDependencyCollector {
    
    public DependencyReport collectDependencies(List<Project> projects) {
        // Implementation details...
    }
    
    public static class DependencyReport {
        public Map<String, Dependency> getConsolidatedDependencies();
        public Map<String, Set<String>> getVersionInconsistencies();
        public List<String> getModulesUsingDependency(String coordinates);
        public boolean hasVersionInconsistencies();
        public String getSummary();
    }
}
----

=== Usage Example

[source,java]
----
// Parse multi-module project
List<Project> projects = parser.parseMultiModuleProject(rootPom);

// Collect and analyze dependencies
MultiModuleDependencyCollector collector = new MultiModuleDependencyCollector();
var report = collector.collectDependencies(projects);

// Check for inconsistencies
if (report.hasVersionInconsistencies()) {
    System.out.println("Version inconsistencies found:");
    report.getVersionInconsistencies().forEach((coords, versions) -> {
        System.out.println("  " + coords + ": " + versions);
    });
}

// Get consolidated view
Map<String, Dependency> consolidated = report.getConsolidatedDependencies();
consolidated.forEach((coords, dependency) -> {
    List<String> modules = report.getModulesUsingDependency(coords);
    System.out.println(coords + " used by: " + modules);
});
----

== Property Resolution

MavGuard handles Maven property resolution including inheritance:

=== Supported Properties

* Built-in Maven properties (`${project.version}`, `${project.groupId}`, etc.)
* User-defined properties in `<properties>` sections
* Parent POM property inheritance
* System properties and environment variables

=== Configuration

[source,java]
----
ParseConfiguration config = ParseConfiguration.builder()
    .resolveProperties(true)
    .followParentChain(true)
    .includeInheritedDependencies(true)
    .build();
    
Project project = parser.parsePomFile(pomFile, config);
----

== Error Handling

=== Exception Types

* **PomParseException**: XML parsing or validation errors
* **PropertyResolutionException**: Property resolution failures
* **IOException**: File access issues

=== Graceful Error Handling

[source,java]
----
try {
    Project project = parser.parsePomFile(pomFile);
} catch (PomParseException e) {
    if (e.getCause() instanceof PropertyResolutionException) {
        // Handle property resolution issues
        logger.warn("Some properties could not be resolved: {}", e.getMessage());
        // Continue with partial parsing if acceptable
    } else {
        // Handle critical parsing errors
        throw new AnalysisException("Cannot parse POM file", e);
    }
}
----

== Advanced Features

=== Custom JAXB Configuration

[source,java]
----
// Custom XML parsing configuration
JAXBContext context = JAXBContext.newInstance(MavenProject.class);
Unmarshaller unmarshaller = context.createUnmarshaller();

// Add custom validation
SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
Schema schema = schemaFactory.newSchema(new File("maven-4.0.0.xsd"));
unmarshaller.setSchema(schema);
----

=== Stream Processing

For large projects, consider stream-based processing:

[source,java]
----
public Stream<Project> parseProjectsStream(File rootPom) {
    return findModulePoms(rootPom)
        .stream()
        .map(this::parseSafely)
        .filter(Optional::isPresent)
        .map(Optional::get);
}

private Optional<Project> parseSafely(File pomFile) {
    try {
        return Optional.of(parser.parsePomFile(pomFile));
    } catch (Exception e) {
        logger.warn("Failed to parse {}: {}", pomFile, e.getMessage());
        return Optional.empty();
    }
}
----

=== Memory Optimization

For very large projects:

[source,java]
----
// Process modules in batches
List<File> modulePoms = findAllModulePoms(rootPom);
int batchSize = 10;

for (int i = 0; i < modulePoms.size(); i += batchSize) {
    List<File> batch = modulePoms.subList(i, Math.min(i + batchSize, modulePoms.size()));
    
    List<Project> projects = batch.stream()
        .map(parser::parsePomFile)
        .collect(Collectors.toList());
        
    // Process batch
    processBatch(projects);
    
    // Clear for memory management
    projects.clear();
    System.gc(); // Hint for garbage collection
}
----

== Integration with Model API

The parser produces domain objects from the model API:

[source,java]
----
// Parser output
Project project = parser.parsePomFile(pomFile);

// Access model objects
ProjectCoordinates coords = project.coordinates();
List<Dependency> dependencies = project.dependencies();
Optional<ProjectCoordinates> parent = project.parent();

// Work with immutable objects
String summary = String.format("Project %s has %d dependencies", 
    coords.toString(), 
    dependencies.size());
----

== Performance Considerations

=== Parallel Processing

[source,java]
----
// Parse modules in parallel
List<Project> projects = modulePoms.parallelStream()
    .map(parser::parsePomFile)
    .collect(Collectors.toList());
----

=== Caching Strategies

[source,java]
----
// Cache parsed parent POMs
Map<File, Project> parentCache = new ConcurrentHashMap<>();

public Project parseWithParentCache(File pomFile) {
    File parentPom = findParentPom(pomFile);
    if (parentPom != null) {
        Project parent = parentCache.computeIfAbsent(parentPom, parser::parsePomFile);
        // Use cached parent for property resolution
    }
    return parser.parsePomFile(pomFile);
}
----

== Next Steps

* Learn about the <<model-api.adoc#,Model API>> for working with parsed objects
* Explore <<../examples/integration-examples.adoc#,integration examples>>
* Review the <<java-api.adoc#,complete Java API guide>>