= Data Flow

This document describes how data flows through MavGuard from POM file input to analysis output.

== Overview

MavGuard processes Maven projects through a series of well-defined stages:

1. **Input Processing** - File system access and validation
2. **XML Parsing** - Converting XML to domain objects
3. **Property Resolution** - Resolving Maven properties and inheritance
4. **Multi-Module Detection** - Identifying project structure
5. **Dependency Aggregation** - Collecting and consolidating dependencies
6. **Version Analysis** - Checking for updates and inconsistencies
7. **Output Formatting** - Presenting results to users

== Detailed Flow

=== Stage 1: Input Processing

```
User Command → File Path Validation → POM File Discovery
```

**Activities**:
- Validate command-line arguments
- Check file accessibility and permissions
- Determine if project is single or multi-module

**Error Handling**:
- File not found errors
- Permission denied errors
- Invalid file format detection

=== Stage 2: XML Parsing

```
POM Files → JAXB Unmarshalling → Raw Maven Objects
```

**Activities**:
- XML syntax validation
- JAXB object creation
- Basic structure validation

**Key Components**:
- JAXB context initialization
- Custom unmarshalling logic
- Error recovery mechanisms

=== Stage 3: Property Resolution

```
Raw Objects → Property Substitution → Resolved Objects
```

**Property Sources** (in precedence order):
1. Command-line system properties
2. POM-defined properties
3. Parent POM properties
4. Built-in Maven properties
5. Environment variables

**Example Resolution**:
```
${spring.version} → 6.2.2 (from parent POM)
${project.version} → 1.0.0 (built-in property)
```

=== Stage 4: Multi-Module Detection

```
Resolved Objects → Module Discovery → Project Hierarchy
```

**Detection Logic**:
1. Check for `<modules>` section in root POM
2. Scan for module directories
3. Build parent-child relationships
4. Validate module structure

**Output**: List of `Project` objects with relationships

=== Stage 5: Dependency Aggregation

```
Project Hierarchy → Dependency Collection → Consolidated View
```

**For Multi-Module Projects**:
- Collect dependencies from all modules
- Apply Maven's conflict resolution rules
- Identify version inconsistencies
- Create consolidated dependency map

**Conflict Resolution**:
- "Nearest wins" dependency resolution
- Scope precedence handling
- Version range resolution

=== Stage 6: Version Analysis

```
Dependencies → Repository Queries → Update Information
```

**Repository Access**:
- Parallel HTTP requests to Maven repositories
- Metadata parsing (maven-metadata.xml)
- Version comparison logic
- Update availability determination

**Performance Optimizations**:
- Connection pooling
- Request batching
- Response caching
- Timeout handling

=== Stage 7: Output Formatting

```
Analysis Results → Format Selection → User Output
```

**Formatting Options**:
- Tabular console output
- Detailed module breakdowns
- Summary statistics
- Error and warning messages

== Data Structures

=== Input Data Flow

```
File System
    ↓
XML Content (String)
    ↓
Maven POM Objects (JAXB)
    ↓
Domain Objects (Records)
    ↓
Analysis Results
    ↓
Formatted Output
```

=== Object Transformations

**XML → JAXB Objects**:
```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
    <version>${spring.version}</version>
</dependency>
```

**JAXB → Domain Objects**:
```java
new Dependency(
    new ProjectCoordinates("org.springframework", "spring-core", "6.2.2"),
    "compile"
)
```

=== Memory Management

**Object Lifecycle**:
1. **Creation**: JAXB objects created during parsing
2. **Transformation**: Converted to immutable domain objects
3. **Analysis**: Temporary analysis objects created
4. **Output**: Results formatted and presented
5. **Cleanup**: Automatic garbage collection of temporary objects

**Memory Optimization**:
- Streaming XML parsing for large files
- Lazy loading of optional information
- Immutable objects for thread safety
- Connection pooling for repository access

== Error Flow

=== Error Propagation

```
Low-Level Errors → Exception Wrapping → User-Friendly Messages
```

**Error Categories**:
- **Parse Errors**: XML syntax, validation failures
- **Resolution Errors**: Property resolution, dependency conflicts
- **Network Errors**: Repository access, timeouts
- **Configuration Errors**: Invalid settings, authentication

=== Graceful Degradation

**Partial Success Strategy**:
1. Continue processing when non-critical operations fail
2. Collect all errors for comprehensive reporting
3. Provide partial results when possible
4. Clear indication of what succeeded vs. failed

**Example**: If property resolution fails for one dependency, continue processing others and report the specific failure.

== Performance Characteristics

=== Scalability Factors

**Project Size**:
- **Single Module**: O(n) where n = number of dependencies
- **Multi-Module**: O(m × n) where m = modules, n = avg dependencies per module

**Network Operations**:
- **Update Checking**: O(d) where d = unique dependencies
- **Parallel Processing**: Reduces to O(d/p) where p = parallel connections

**Memory Usage**:
- **Heap**: Linear with total number of dependencies
- **Network Buffers**: Fixed size connection pools
- **Temporary Objects**: Created and cleaned up per operation

=== Optimization Strategies

**Parsing Optimization**:
- JAXB streaming for large POMs
- Property resolution caching
- Incremental multi-module discovery

**Network Optimization**:
- HTTP/2 connection reuse
- Request batching and pipelining
- Intelligent caching with TTL
- Circuit breaker for failing repositories

**Memory Optimization**:
- Immutable object sharing
- Lazy evaluation of expensive operations
- Garbage collection friendly patterns

== Integration Points

=== External System Interactions

**File System**:
- Read POM files and module structure
- Handle different file encodings
- Respect file permissions and access controls

**Maven Repositories**:
- HTTP/HTTPS communication
- Authentication handling (basic, token-based)
- Proxy support for corporate environments
- Rate limiting and retry logic

**Configuration System**:
- Property file loading
- Environment variable resolution
- Command-line argument processing
- Profile-based configuration

=== Internal Module Communication

**Service Layer Communication**:
```
CLI Commands → Parser Services → Repository Services → Domain Objects
```

**Data Sharing**:
- Immutable domain objects passed between layers
- Configuration objects injected via dependency injection
- Error objects propagated through exception hierarchy

For implementation details, see:
- <<overview.adoc#,Architecture Overview>>
- <<modules.adoc#,Module Documentation>>
- <<../api/java-api.adoc#,Java API Guide>>